<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Krylov.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krylov.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Krylov methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solvers/spd/">Symmetric positive definite linear systems</a></li><li><a class="tocitem" href="../solvers/sid/">Symmetric indefinite linear systems</a></li><li><a class="tocitem" href="../solvers/unsymmetric/">Unsymmetric linear systems</a></li><li><a class="tocitem" href="../solvers/ln/">Minimum-norm problems</a></li><li><a class="tocitem" href="../solvers/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../solvers/as/">Adjoint systems</a></li><li><a class="tocitem" href="../solvers/sp_sqd/">Saddle-point and symmetric quasi-definite systems</a></li><li><a class="tocitem" href="../solvers/gsp/">Generalized saddle-point and unsymmetric partitioned systems</a></li></ul></li><li><a class="tocitem" href="../inplace/">In-place methods</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../gpu/">GPU support</a></li><li><a class="tocitem" href="../warm_start/">Warm start</a></li><li><a class="tocitem" href="../factorization-free/">Factorization-free operators</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../tips/">Performance tips</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#CG"><span>CG</span></a></li><li><a class="tocitem" href="#CG-LANCZOS-SHIFT"><span>CG-LANCZOS-SHIFT</span></a></li><li><a class="tocitem" href="#SYMMLQ"><span>SYMMLQ</span></a></li><li><a class="tocitem" href="#MINRES-QLP"><span>MINRES-QLP</span></a></li><li><a class="tocitem" href="#TriCG"><span>TriCG</span></a></li><li><a class="tocitem" href="#TriMR"><span>TriMR</span></a></li><li><a class="tocitem" href="#BICGSTAB"><span>BICGSTAB</span></a></li><li><a class="tocitem" href="#DQGMRES"><span>DQGMRES</span></a></li><li><a class="tocitem" href="#CGNE"><span>CGNE</span></a></li><li><a class="tocitem" href="#CRMR"><span>CRMR</span></a></li><li><a class="tocitem" href="#CRAIG"><span>CRAIG</span></a></li><li><a class="tocitem" href="#CRAIGMR"><span>CRAIGMR</span></a></li><li><a class="tocitem" href="#CGLS"><span>CGLS</span></a></li><li><a class="tocitem" href="#CRLS"><span>CRLS</span></a></li><li><a class="tocitem" href="#LSQR"><span>LSQR</span></a></li><li><a class="tocitem" href="#LSMR"><span>LSMR</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="CG"><a class="docs-heading-anchor" href="#CG">CG</a><a id="CG-1"></a><a class="docs-heading-anchor-permalink" href="#CG" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, MatrixMarket, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;bcsstk09&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

n = matrix.nrows[1]
A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = ones(n)
b_norm = norm(b)

# Solve Ax = b.
(x, stats) = cg(A, b)
show(stats)
r = b - A * x
@printf(&quot;Relative residual: %8.1e\n&quot;, norm(r) / b_norm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/bcsstk09.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/bcsstk09.MM
Simple stats
 niter: 214
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
Relative residual:  1.3e-08</code></pre><h2 id="CG-LANCZOS-SHIFT"><a class="docs-heading-anchor" href="#CG-LANCZOS-SHIFT">CG-LANCZOS-SHIFT</a><a id="CG-LANCZOS-SHIFT-1"></a><a class="docs-heading-anchor-permalink" href="#CG-LANCZOS-SHIFT" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, MatrixMarket, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

function residuals(A, b, shifts, x)
  nshifts = length(shifts)
  r = [ (b - A * x[i] - shifts[i] * x[i]) for i = 1 : nshifts ]
  return r
end
ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;1138_bus&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
n, m = size(A)
b = ones(n)

# Solve (A + αI)x = b.
shifts = [1.0, 2.0, 3.0, 4.0]
(x, stats) = cg_lanczos_shift(A, b, shifts)
show(stats)
r = residuals(A, b, shifts, x)
resids = map(norm, r) / norm(b)
@printf(&quot;Relative residuals with shifts:\n&quot;)
for resid in resids
  @printf(&quot; %8.1e&quot;, resid)
end
@printf(&quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/1138_bus.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/1138_bus.MM
LanczosShift stats
 niter: 726
 solved: true
 residuals: [Float64[], Float64[], Float64[], Float64[]]
 indefinite: Bool[0, 1, 1, 1]
 ‖A‖F: NaN
 κ₂(A): NaN
 status: solution good enough given atol and rtol
Relative residuals with shifts:
  1.5e-08  1.5e-08  1.3e-08  1.3e-08</code></pre><h2 id="SYMMLQ"><a class="docs-heading-anchor" href="#SYMMLQ">SYMMLQ</a><a id="SYMMLQ-1"></a><a class="docs-heading-anchor-permalink" href="#SYMMLQ" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov
using LinearAlgebra, Printf

A = diagm([1.0; 2.0; 3.0; 0.0])
n = size(A, 1)
b = [1.0; 2.0; 3.0; 0.0]
b_norm = norm(b)

# SYMMLQ returns the minimum-norm solution of symmetric, singular and consistent systems
(x, stats) = symmlq(A, b, transfer_to_cg=false);
r = b - A * x;

@printf(&quot;Residual r: %s\n&quot;, Krylov.vec2str(r))
@printf(&quot;Relative residual norm ‖r‖: %8.1e\n&quot;, norm(r) / b_norm)
@printf(&quot;Solution x: %s\n&quot;, Krylov.vec2str(x))
@printf(&quot;Minimum-norm solution? %s\n&quot;, x ≈ [1.0; 1.0; 1.0; 0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Residual r: [ 1.1e-16  2.2e-16  0.0e+00  0.0e+00 ]
Relative residual norm ‖r‖:  6.6e-17
Solution x: [ 1.0e+00  1.0e+00  1.0e+00  0.0e+00 ]
Minimum-norm solution? true</code></pre><h2 id="MINRES-QLP"><a class="docs-heading-anchor" href="#MINRES-QLP">MINRES-QLP</a><a id="MINRES-QLP-1"></a><a class="docs-heading-anchor-permalink" href="#MINRES-QLP" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov
using LinearAlgebra, Printf

A = diagm([1.0; 2.0; 3.0; 0.0])
n = size(A, 1)
b = [1.0; 2.0; 3.0; 4.0]
b_norm = norm(b)

# MINRES-QLP returns the minimum-norm solution of symmetric, singular and inconsistent systems
(x, stats) = minres_qlp(A, b);
r = b - A * x;

@printf(&quot;Residual r: %s\n&quot;, Krylov.vec2str(r))
@printf(&quot;Relative residual norm ‖r‖: %8.1e\n&quot;, norm(r) / b_norm)
@printf(&quot;Solution x: %s\n&quot;, Krylov.vec2str(x))
@printf(&quot;Minimum-norm solution? %s\n&quot;, x ≈ [1.0; 1.0; 1.0; 0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Residual r: [-6.2e-15  2.9e-15  2.2e-15  4.0e+00 ]
Relative residual norm ‖r‖:  7.3e-01
Solution x: [ 1.0e+00  1.0e+00  1.0e+00 -9.6e-16 ]
Minimum-norm solution? true</code></pre><h2 id="TriCG"><a class="docs-heading-anchor" href="#TriCG">TriCG</a><a id="TriCG-1"></a><a class="docs-heading-anchor-permalink" href="#TriCG" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators
using LinearAlgebra, Printf, SparseArrays

# Identity matrix.
eye(n::Int) = sparse(1.0 * I, n, n)

# Symmetric quasi-definite systems and variants
n = m = 5
A = [2^(i/j)*j + (-1)^(i-j) * n*(i-1) for i = 1:n, j = 1:n]
b = ones(n)
M = diagm(0 =&gt; [3.0 * i for i = 1:n])
N = diagm(0 =&gt; [5.0 * i for i = 1:n])
c = -b

# [I   A] [x] = [b]
# [Aᵀ -I] [y]   [c]
(x, y, stats) = tricg(A, b, c)
K = [eye(m) A; A&#39; -eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [-I   A] [x] = [b]
# [ Aᵀ  I] [y]   [c]
(x, y, stats) = tricg(A, b, c, flip=true)
K = [-eye(m) A; A&#39; eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [I   A] [x] = [b]
# [Aᵀ  I] [y]   [c]
(x, y, stats) = tricg(A, b, c, spd=true)
K = [eye(m) A; A&#39; eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [-I    A] [x] = [b]
# [ Aᵀ  -I] [y]   [c]
(x, y, stats) = tricg(A, b, c, snd=true)
K = [-eye(m) A; A&#39; -eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [τI    A] [x] = [b]
# [ Aᵀ  νI] [y]   [c]
(τ, ν) = (1e-4, 1e2)
(x, y, stats) = tricg(A, b, c, τ=τ, ν=ν)
K = [τ*eye(m) A; A&#39; ν*eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [M⁻¹  A  ] [x] = [b]
# [Aᵀ  -N⁻¹] [y]   [c]
(x, y, stats) = tricg(A, b, c, M=M, N=N, verbose=1)
K = [inv(M) A; A&#39; -inv(N)]
H = BlockDiagonalOperator(M, N)
B = [b; c]
r = B - K * [x; y]
resid = sqrt(dot(r, H * r))
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TriCG: Relative residual:  2.8e-11
TriCG: Relative residual:  8.2e-12
TriCG: Relative residual:  1.2e-11
TriCG: Relative residual:  4.3e-11
TriCG: Relative residual:  3.5e-10
TriCG: system of 10 equations in 10 variables
    k     ‖rₖ‖     βₖ₊₁     γₖ₊₁
    0  1.1e+01  6.7e+00  8.7e+00
    1  5.8e+00  2.6e+02  3.0e+02
    2  2.5e+00  2.9e+02  2.2e+02
    3  1.2e+00  2.4e+01  5.5e+01
    4  1.9e-01  3.4e-01  8.1e-01
    5  2.7e-08  1.5e-07  9.0e-08

TriCG: Relative residual:  2.7e-08</code></pre><h2 id="TriMR"><a class="docs-heading-anchor" href="#TriMR">TriMR</a><a id="TriMR-1"></a><a class="docs-heading-anchor-permalink" href="#TriMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators, LDLFactorizations
using LinearAlgebra, Printf, SparseArrays

# Identity matrix.
eye(n::Int) = sparse(1.0 * I, n, n)

# Saddle-point systems
n = m = 5
A = [2^(i/j)*j + (-1)^(i-j) * n*(i-1) for i = 1:n, j = 1:n]
b = ones(n)
D = diagm(0 =&gt; [2.0 * i for i = 1:n])
m, n = size(A)
c = -b

# [D   A] [x] = [b]
# [Aᵀ  0] [y]   [c]
llt_D = cholesky(D)
opD⁻¹ = LinearOperator(Float64, 5, 5, true, true, (y, v) -&gt; ldiv!(y, llt_D, v))
opH⁻¹ = BlockDiagonalOperator(opD⁻¹, eye(n))
(x, y, stats) = trimr(A, b, c, M=opD⁻¹, sp=true)
K = [D A; A&#39; zeros(n,n)]
B = [b; c]
r = B - K * [x; y]
resid = sqrt(dot(r, opH⁻¹ * r))
@printf(&quot;TriMR: Relative residual: %8.1e\n&quot;, resid)

# Symmetric quasi-definite systems
n = m = 5
A = [2^(i/j)*j + (-1)^(i-j) * n*(i-1) for i = 1:n, j = 1:n]
b = ones(n)
M = diagm(0 =&gt; [3.0 * i for i = 1:n])
N = diagm(0 =&gt; [5.0 * i for i = 1:n])
c = -b

# [I   A] [x] = [b]
# [Aᵀ -I] [y]   [c]
(x, y, stats) = trimr(A, b, c)
K = [eye(m) A; A&#39; -eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriMR: Relative residual: %8.1e\n&quot;, resid)

# [M   A] [x] = [b]
# [Aᵀ -N] [y]   [c]
ldlt_M = ldl(M)
ldlt_N = ldl(N)
opM⁻¹ = LinearOperator(Float64, size(M,1), size(M,2), true, true, (y, v) -&gt; ldiv!(y, ldlt_M, v))
opN⁻¹ = LinearOperator(Float64, size(N,1), size(N,2), true, true, (y, v) -&gt; ldiv!(y, ldlt_N, v))
opH⁻¹ = BlockDiagonalOperator(opM⁻¹, opN⁻¹)
(x, y, stats) = trimr(A, b, c, M=opM⁻¹, N=opN⁻¹, verbose=1)
K = [M A; A&#39; -N]
B = [b; c]
r = B - K * [x; y]
resid = sqrt(dot(r, opH⁻¹ * r))
@printf(&quot;TriMR: Relative residual: %8.1e\n&quot;, resid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TriMR: Relative residual:  3.4e-09
TriMR: Relative residual:  2.8e-11
TriMR: system of 10 equations in 10 variables
    k     ‖rₖ‖     βₖ₊₁     γₖ₊₁
    0  1.1e+00  8.7e-01  6.8e-01
    1  7.3e-01  4.0e+00  8.8e-01
    2  4.4e-01  2.2e+00  2.0e+00
    3  3.2e-01  9.3e-02  1.4e+00
    4  2.2e-03  1.0e-02  7.0e-03
    5  2.0e-13  5.8e-10  3.3e-11

TriMR: Relative residual:  2.0e-13</code></pre><h2 id="BICGSTAB"><a class="docs-heading-anchor" href="#BICGSTAB">BICGSTAB</a><a id="BICGSTAB-1"></a><a class="docs-heading-anchor-permalink" href="#BICGSTAB" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators, IncompleteLU, HarwellRutherfordBoeing
using LinearAlgebra, Printf, SuiteSparseMatrixCollection, SparseArrays

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;sherman5&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

n = matrix.nrows[1]
A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
b = A * ones(n)

F = ilu(A, τ = 0.05)

@printf(&quot;nnz(ILU) / nnz(A): %7.1e\n&quot;, nnz(F) / nnz(A))

# Solve Ax = b with BICGSTAB and an incomplete LU factorization
# Remark: CGS can be used in the same way
opM = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; forward_substitution!(y, F, v))
opN = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; backward_substitution!(y, F, v))
opP = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; ldiv!(y, F, v))

# Without preconditioning
x, stats = bicgstab(A, b, history=true)
r = b - A * x
@printf(&quot;[Without preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Without preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Split preconditioning
x, stats = bicgstab(A, b, history=true, M=opM, N=opN)
r = b - A * x
@printf(&quot;[Split preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Split preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Left preconditioning
x, stats = bicgstab(A, b, history=true, M=opP)
r = b - A * x
@printf(&quot;[Left preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Left preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Right preconditioning
x, stats = bicgstab(A, b, history=true, N=opP)
r = b - A * x
@printf(&quot;[Right preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Right preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/sherman5.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/sherman5.RB
nnz(ILU) / nnz(A): 3.1e+00
[Without preconditioning] Residual norm:  4.6e-05
[Without preconditioning] Number of iterations: 1967
[Split preconditioning] Residual norm:  9.0e-07
[Split preconditioning] Number of iterations:   9
[Left preconditioning] Residual norm:  3.2e-07
[Left preconditioning] Number of iterations:   9
[Right preconditioning] Residual norm:  7.8e-06
[Right preconditioning] Number of iterations:   8</code></pre><h2 id="DQGMRES"><a class="docs-heading-anchor" href="#DQGMRES">DQGMRES</a><a id="DQGMRES-1"></a><a class="docs-heading-anchor-permalink" href="#DQGMRES" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators, ILUZero, MatrixMarket
using LinearAlgebra, Printf, SuiteSparseMatrixCollection

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;Simon&quot;, &quot;raefsky1&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

n = matrix.nrows[1]
A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = A * ones(n)

F = ilu0(A)

@printf(&quot;nnz(ILU) / nnz(A): %7.1e\n&quot;, nnz(F) / nnz(A))

# Solve Ax = b with DQGMRES and an ILU(0) preconditioner
# Remark: DIOM, FOM and GMRES can be used in the same way
opM = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; forward_substitution!(y, F, v))
opN = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; backward_substitution!(y, F, v))
opP = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; ldiv!(y, F, v))

# Without preconditioning
x, stats = dqgmres(A, b, memory=50, history=true)
r = b - A * x
@printf(&quot;[Without preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Without preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Split preconditioning
x, stats = dqgmres(A, b, memory=50, history=true, M=opM, N=opN)
r = b - A * x
@printf(&quot;[Split preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Split preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Left preconditioning
x, stats = dqgmres(A, b, memory=50, history=true, M=opP)
r = b - A * x
@printf(&quot;[Left preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Left preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Right preconditioning
x, stats = dqgmres(A, b, memory=50, history=true, N=opP)
r = b - A * x
@printf(&quot;[Right preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Right preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: Simon/raefsky1.MM
nnz(ILU) / nnz(A): 1.0e+00
[Without preconditioning] Residual norm:  9.6e-07
[Without preconditioning] Number of iterations: 3716
[Split preconditioning] Residual norm:  3.8e-07
[Split preconditioning] Number of iterations:  33
[Left preconditioning] Residual norm:  7.6e-08
[Left preconditioning] Number of iterations:  34
[Right preconditioning] Residual norm:  3.4e-07
[Right preconditioning] Number of iterations:  33</code></pre><h2 id="CGNE"><a class="docs-heading-anchor" href="#CGNE">CGNE</a><a id="CGNE-1"></a><a class="docs-heading-anchor-permalink" href="#CGNE" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, HarwellRutherfordBoeing, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;wm2&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

x_exact = A&#39; * ones(m)
x_exact_norm = norm(x_exact)
x_exact /= x_exact_norm
b = A * x_exact
(x, stats) = cgne(A, b)
show(stats)
resid = norm(A * x - b) / norm(b)
@printf(&quot;CGNE: Relative residual: %7.1e\n&quot;, resid)
@printf(&quot;CGNE: ‖x - x*‖₂: %7.1e\n&quot;, norm(x - x_exact))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm2.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm2.RB
System size: 207 rows and 260 columns
Simple stats
 niter: 213
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
CGNE: Relative residual: 1.5e-08
CGNE: ‖x - x*‖₂: 3.2e-07</code></pre><h2 id="CRMR"><a class="docs-heading-anchor" href="#CRMR">CRMR</a><a id="CRMR-1"></a><a class="docs-heading-anchor-permalink" href="#CRMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, HarwellRutherfordBoeing, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;gemat1&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

x_exact = A&#39; * ones(m)
x_exact_norm = norm(x_exact)
x_exact /= x_exact_norm
b = A * x_exact
(x, stats) = crmr(A, b)
show(stats)
resid = norm(A * x - b) / norm(b)
@printf(&quot;CRMR: Relative residual: %7.1e\n&quot;, resid)
@printf(&quot;CRMR: ‖x - x*‖₂: %7.1e\n&quot;, norm(x - x_exact))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/gemat1.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/gemat11.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/gemat12.RB
System size: 4929 rows and 10595 columns
Simple stats
 niter: 7
 solved: false
 inconsistent: true
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: system probably inconsistent but least squares/norm solution found
CRMR: Relative residual: 4.0e-06
CRMR: ‖x - x*‖₂: 6.3e-03</code></pre><h2 id="CRAIG"><a class="docs-heading-anchor" href="#CRAIG">CRAIG</a><a id="CRAIG-1"></a><a class="docs-heading-anchor-permalink" href="#CRAIG" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov
using LinearAlgebra, Printf

m = 5
n = 8
λ = 1.0e-3
A = rand(m, n)
b = A * ones(n)
xy_exact = [A  λ*I] \ b # In Julia, this is the min-norm solution!

(x, y, stats) = craig(A, b, λ=λ, atol=0.0, rtol=1.0e-20, verbose=1)
show(stats)

# Check that we have a minimum-norm solution.
# When λ &gt; 0 we solve min ‖(x,s)‖  s.t. Ax + λs = b, and we get s = λy.
@printf(&quot;Primal feasibility: %7.1e\n&quot;, norm(b - A * x - λ^2 * y) / norm(b))
@printf(&quot;Dual   feasibility: %7.1e\n&quot;, norm(x - A&#39; * y) / norm(x))
@printf(&quot;Error in x: %7.1e\n&quot;, norm(x - xy_exact[1:n]) / norm(xy_exact[1:n]))
if λ &gt; 0.0
  @printf(&quot;Error in y: %7.1e\n&quot;, norm(λ * y - xy_exact[n+1:n+m]) / norm(xy_exact[n+1:n+m]))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CRAIG: system of 5 equations in 8 variables
    k       ‖r‖       ‖x‖       ‖A‖      κ(A)         α        β
    0  9.22e+00  0.00e+00  0.00e+00  0.00e+00
    1  1.17e-01  2.79e+00  3.30e+00  3.30e+00   3.3e+00  4.2e-02
    2  3.41e-02  2.80e+00  3.50e+00  4.95e+00   1.1e+00  3.2e-01
    3  6.52e-03  2.80e+00  3.60e+00  6.27e+00   8.2e-01  1.6e-01
    4  2.48e-03  2.80e+00  3.66e+00  7.37e+00   6.2e-01  2.3e-01
    5  6.41e-10  2.80e+00  3.67e+00  8.32e+00   3.5e-01  9.1e-08

Simple stats
 niter: 5
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough for the tolerances given
Primal feasibility: 7.0e-11
Dual   feasibility: 2.7e-16
Error in x: 6.9e-11
Error in y: 6.9e-11</code></pre><h2 id="CRAIGMR"><a class="docs-heading-anchor" href="#CRAIGMR">CRAIGMR</a><a id="CRAIGMR-1"></a><a class="docs-heading-anchor-permalink" href="#CRAIGMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, HarwellRutherfordBoeing, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;wm1&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

x_exact = A&#39; * ones(m)
x_exact_norm = norm(x_exact)
x_exact /= x_exact_norm
b = A * x_exact
(x, y, stats) = craigmr(A, b)
show(stats)
resid = norm(A * x - b) / norm(b)
@printf(&quot;CRAIGMR: Relative residual: %7.1e\n&quot;, resid)
@printf(&quot;CRAIGMR: ‖x - x*‖₂: %7.1e\n&quot;, norm(x - x_exact))
@printf(&quot;CRAIGMR: %d iterations\n&quot;, length(stats.residuals))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm1.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm1.RB
System size: 207 rows and 277 columns
Simple stats
 niter: 115
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: found approximate minimum-norm solution
CRAIGMR: Relative residual: 1.3e-08
CRAIGMR: ‖x - x*‖₂: 1.3e-05
CRAIGMR: 0 iterations</code></pre><h2 id="CGLS"><a class="docs-heading-anchor" href="#CGLS">CGLS</a><a id="CGLS-1"></a><a class="docs-heading-anchor-permalink" href="#CGLS" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;well1033&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter.
λ = 1.0e-3

(x, stats) = cgls(A, b, λ=λ)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;CGLS: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;CGLS: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/well1033.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/well1033.MM
System size: 1033 rows and 320 columns
Simple stats
 niter: 121
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
CGLS: Relative residual:  1.9e-08
CGLS: ‖x‖:  8.4e+03</code></pre><h2 id="CRLS"><a class="docs-heading-anchor" href="#CRLS">CRLS</a><a id="CRLS-1"></a><a class="docs-heading-anchor-permalink" href="#CRLS" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;well1850&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter.
λ = 1.0e-3

(x, stats) = crls(A, b, λ=λ)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;CRLS: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;CRLS: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/well1850.MM
System size: 1850 rows and 712 columns
Simple stats
 niter: 259
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
CRLS: Relative residual:  2.0e-08
CRLS: ‖x‖:  1.0e+04</code></pre><h2 id="LSQR"><a class="docs-heading-anchor" href="#LSQR">LSQR</a><a id="LSQR-1"></a><a class="docs-heading-anchor-permalink" href="#LSQR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;illc1033&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter.
λ = 1.0e-3

(x, stats) = lsqr(A, b, λ=λ, atol=0.0, btol=0.0)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;LSQR: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;LSQR: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/illc1033.MM
System size: 1033 rows and 320 columns
Simple stats
 niter: 1353
 solved: false
 inconsistent: true
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: maximum number of iterations exceeded
LSQR: Relative residual:  1.4e-03
LSQR: ‖x‖:  9.4e+03</code></pre><h2 id="LSMR"><a class="docs-heading-anchor" href="#LSMR">LSMR</a><a id="LSMR-1"></a><a class="docs-heading-anchor-permalink" href="#LSMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;illc1850&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter.
λ = 1.0e-3

(x, stats) = lsmr(A, b, λ=λ, atol=0.0, btol=0.0)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;LSMR: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;LSMR: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/illc1850.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/illc1850.MM
System size: 1850 rows and 712 columns
Lsmr stats
 niter: 1089
 solved: true
 inconsistent: true
 residuals: []
 Aresiduals: []
 residual: 16.205302719154798
 Aresidual: 0.001744668542011466
 κ₂(A): 67.13806544631052
 ‖A‖F: 45.016285250483314
 xNorm: 16060.854604524206
 status: truncated forward error small enough
LSMR: Relative residual:  2.4e-03
LSMR: ‖x‖:  1.6e+04</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tips/">« Performance tips</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Friday 19 August 2022 03:16">Friday 19 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
